## let,const 블록레벨 스코프

함수 내부에서 선언된 변수 이외에는 모두 전역 변수다. 

**사실 전역 스코프는 2개가 있는 것**

- 이전에는 전역 스코프라고하는 물리적인 실체가 윈도우에 있었다. 윈도우가 스코프의 역할도 했다.
- 윈도우는 윈도우 대로 , let, const 전역 변수는 다른 곳에 저장되게 만들어놨다.

**빌트인이 존재한다는 것은 전역 스코프에 존재한다는 것**

**const는 매우 중요하다**

- 변수를 선언할때 선택지 var, let, const 그럼 우리는 무엇을 선택해서 사용해야할까?

**프로그래밍 언어에서 상수라는 단어는 조심해서 사용하자** 

- 상수는 불변하는 값이다.
- `const a = 1;` ➡️ 1이 상수이기 때문에 상수다. a는 상수가 아니라는 의미다.
- `const a = {}` 는 상수가 될 수 없다.
    - 객체를 불변하게 만들려면? 동결 시켜야한다. → 작업하는 일이 번거롭지만 신뢰성을 얻을 수 있다.

결론적으로 const는 상수라고 할 수 없다. 재할당을 금하는 것

**변수를 선언할 땐 무조건 const 사용하자.**

var는 앞으로 금지!

## 프로퍼티 어트리뷰트

**객체란 속성을 나타낸것** 

- 속성은? 개념의 특징들을 나열한것

**객체지향은 우리가 관심이 있는 속성이 있는 것들만 모아놓은 것 (추상화)**

**프로퍼티 어트리뷰트란 무엇일까?**

- 4개의 숨겨진 내부 슬롯을 가지고 있다. 그 내부 슬롯이 프로퍼티다.
- 프로퍼티라고 하는 것이 객체 취급되고 있다.
- 객체 취급되니까 값이 될 수 있다.

**parentNode는 접근자 프로퍼티이다.**

- 왜 함수로 사용하지 않고 프로퍼티로 사용할까?
- 인수가 없는 함수라면 프로퍼티가 낫지않을까?

**프로퍼티 어트리뷰트가 무슨 뜻일까?**

- 어트리뷰트란? → 가지고 있는 특징
- 뭔가를 설명하는 데이터
- 즉, **프로퍼티를 설명하기 위해 존재하는 데이터**
- [[value]]는? 프로퍼티 값을 나타낸다.
    
    ```jsx
    const o = {
    	a : 1,
    }
    ```
    
- 파싱이되서 c++이 된 객체들 중 몇가지의 정보만 제공한다.
- 제공된 프로퍼티는 내부슬롯이라 부른다.
- 프로퍼티 중에서도 메서드가 있을 거 아닌가? 그걸 내부 메서드라고한다.

**우리는 값만 지정해주었는데 그럼 나머지 3개의 어트리뷰트는 무엇으로 저장될까?** 

- 기본값으로 저장되어있을 것

**순회는?  →  순서가 있다. 대상은? 순서가 있는 자료구조(배열)**

- 가장 기본적인 문법 - for문

**열거는? → 순서가 없다. 대상은? 순서가 없는 자료구조(객체) 객체는 키가 있다.** 

- 객체의 데이터는 어떻게 뽑아올까? 프로퍼티의 키로 가져온다.
- 문법 - Object.keys/values/entries
    
    

**데이터 프로퍼티는 어떻게 돌아갈까?**

1. 스코프로 찾으러 가자 - 전역에 있다 존재한다
2. person.이라는 것은? person이 객체인지를 확인한다.
3. firstName는 프로퍼티 키여야한다.  - person객체 안에 존재하는지 찾는다. 

**접근자 프로퍼티는 어떻게 돌아갈까?**

- 접근자 프로퍼티  get의 값은 뭐가 들어와야하는거지? → 함수가 들어와야한다.
- 접근자 프로퍼티이기때문에 **프로퍼티처럼 써야하는 것!!!!!!**
1. fullName이 있는지 확인한다 
    1. 없으면 동적으로 생성해야하기 때문에 
2. 있으면 데이터 프로퍼티인지 접근자프로퍼티인지 확인하기
3. 할당식은 setter가 실행된다. 

여기서 알수있는 것 setter는 매개변수를 몇개 가져야할까?  → 무조건 1개!

getter 함수는 매개변수가 없어도된다.  - 참조하는 역할이기 때문에

그렇지만 결과물이 있어야하기 때문에 return이 있어야한다. 

## 생성자 함수

**생성자함수를 언제 써야하지?**

객체 리터럴은 언제 쓰는게 유용할까? → 하나만 만들때 유리하다.

동일한 객체를 만들어야한다라는 것 →  하나 이상의 객체를 만들어야 할 때 유리하다.

**대부분의 경우는 하나만 만들 때가 많다.** 

1. 유지보수성이 떨어진다. 
2. 함수를 1개 만들어도 되는 것을 100개 만들었다는 것 → 좋을게 하나도 없다.

**외워버리기**

전역에서 또는 일반 함수 내부의 this는 전역 객체

객체 리터럴 내부의 this는 메서드를 호출한 객체(호출될 당시의 . 앞에 있는 객체)

생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스

**생성자 함수는 암묵적 처리를 3가지한다.** 

1. 빈 객체 생성
2. this 바인딩 (this에는 값을 할당할 수 없다. 바인딩하는것)
3. return this 

**상속의 매커니즘이 프로토타입이다**. 

Circle이라는 함수 객체가 만들어지는 타이밍? → 전역 코드의 평가시점

**모든 함수 객체는 프로토타입 프로퍼티를 가진다.** 

서클이라는 객체가 있다. → 여기에는 프로토타입 프로퍼티가 암묵적으로 생성된다. 

그 값이뭐냐? circle.prototype

**스코프체인과 프로토타입 체인의 관계** 

스코프 체인은 식별자가 저장되어있고 식별자를 찾는 것

프로퍼티가 저장되어있고 프로토타입을 찾는 것

```jsx
function foo() {
  console.log(this);
}
// 무슨 함수?
// 일반 함수 window 
// [[Call]]
foo(); 

// 생성자 함수 {}
// [[Counstruct]]
new foo(); 

// 메서드
const o = { foo };
o.foo(); 

// 함수의 문제점
// 일반함수로 호출될지 생성자 함수로 호출될지 모른다는 것이다. 
// 일반함수로 호출된다해도 함수 객체는 prototype 프로퍼티를 생성한다. 

// constructor이기 때문에 생기는 문제
// 생성자 함수로 호출이 안될 지언정 prototype 프로퍼티를 생성한다. 이게 옳은 일인가?

// 화살표 함수의 탄생 원인
// 화살표 함수는 non-constructor이다. 그렇기 때문에 prototype을 만들지 않는다.
```
